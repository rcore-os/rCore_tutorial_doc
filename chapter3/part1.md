## rv64 中断介绍

### 再看 rv64 权限模式

> **[info] 再看 riscv64 的 M Mode**
>
> M-mode(机器模式，缩写为 M 模式)是 RISC-V 中 hart(hardware thread,硬件线程)可以执行的最高权限模式。在 M 模式下运行的 hart 对内存,I/O 和一些对于启动和配置系统来说必要的底层功能有着完全的使用权。默认情况下,发生所有异常(不论在什么权限模式下)的时候,控制权都会被移交到 M 模式的异常处理程序。它是唯一所有标准 RISC-V 处理器都必须实现的权限模式。
>
> **再看 riscv64 的 S Mode**
>
> S-mode(监管者模式，缩写为 S 模式)是支持现代类 Unix 操作系统的权限模式，支持基于页面的虚拟内存机制是其核心。 Unix 系统中的大多数例外都应该进行 S 模式下的系统调用。M 模式的异常处理程序可以将异常重新导向 S 模式，也支持通过异常委托机制（Machine Interrupt Delegation,机器中断委托）选择性地将中断和同步异常直接交给 S 模式处理,而完全绕过 M 模式。

### rv64 中断相关寄存器

下面的寄存器主要用于设置或保存中断相关的静态或动态信息。

> ** [info] 中断相关寄存器 **
>
> 当我们触发中断进入 S 态进行处理时，以下寄存器会被硬件自动设置：
>
> **sepc**(exception program counter)，它会记录触发中断的那条指令的地址；
>
> **scause**，它会记录中断发生的原因，还会记录该中断是不是一个外部中断；
>
> **stval**，它会记录一些中断处理所需要的辅助信息，比如取指、访存、缺页异常，它会把发生问题的目标地址记录下来，这样我们在中断处理程序中就知道处理目标了。
>
> 还有一些中断配置的寄存器：
>
> **stvec**，设置如何寻找 S 态中断处理程序的起始地址，保存了中断向量表基址 BASE，同时还有模式 MODE。
>
> 当$$\text{MODE}=0$$，设置为 Direct 模式时，无论中断因何发生我们都直接跳转到基址$$\text{pc}\leftarrow\text{BASE}$$。
>
> 当$$\text{MODE}=1$$时，设置为 Vectored 模式时，遇到中断我们会进行跳转如下：$$\text{pc}\leftarrow\text{BASE}+4\times\text{cause}$$。而这样，我们只需将各中断处理程序放在正确的位置，并设置好 stvec ，遇到中断的时候硬件根据中断原因就会自动跳转到对应的中断处理程序了；
>
> **sstatus**，S 态控制状态寄存器。保存全局中断使能标志，以及许多其他的状态。可设置此寄存器来中断使能与否。

### rv64 中断相关特权指令

我们再来看一下中断相关的指令。

> ** [info] 中断相关指令 **
>
> **ecall**(environment call)，当我们在 S 态执行这条指令时，会触发一个 ecall-from-s-mode-exception，从而进入 M 模式中的中断处理流程（如设置定时器等）；当我们在 U 态执行这条指令时，会触发一个 ecall-from-u-mode-exception，从而进入 S 模式中的中断处理流程（常用来进行系统调用）。
>
> **sret**，用于 S 态中断返回到 U 态，实际作用为$$\text{pc}\leftarrow\text{sepc}$$，回顾**sepc**定义，返回到通过中断进入 S 态之前的地址。
>
> **ebreak**(environment break)，执行这条指令会触发一个断点中断从而进入中断处理流程。
>
> **mret**，用于 M 态中断返回到 S 态或 U 态，实际作用为$$\text{pc}\leftarrow\text{mepc}$$，回顾**sepc**定义，返回到通过中断进入 M 态之前的地址。（一般不用涉及）
